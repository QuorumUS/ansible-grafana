from __future__ import with_statement
import os
import re
import sys
import fnmatch
import functools
import contextlib
import subprocess
from cStringIO import StringIO
from path import Path
from termcolor import colored


# Not using re.VERBOSE because we need to match a '#' for git.
VCS = {
    'svn': r"^(?:A|M)\s+"  # Find Added or Modified files.
           r"(.*)$",       # Store the rest of the line (the filepath).

    'git': r"^#?\s+"                     # The line starts with an octothorpe and whitespace.
           r"(?:new file|modified):\s+"  # Look for new/modified files.
           r"(.*)$",                     # Store the rest of the line (the filepath).
}


IGNORE = ['.*', '*~', '*.py[co]', '*.egg', '*.sqlite']

checkers = []


@contextlib.contextmanager
def captured_output():
    """
    Temporarily redirects stdout to the yielded stream.
    """

    stdout = sys.stdout
    stream = StringIO()
    sys.stdout = stream
    try:
        yield stream
    finally:
        sys.stdout = stdout


def checker(include=['*'], excludes=[], name="", color="", level="error"):
    """
    Decorator to register `func` in `checkers` and normalize output.
    """

    def decorator(func):
        """
        Makes this function a decorator
        """

        @functools.wraps(func)
        def helper(files):
            files_out = []
            for pattern in include:
                files_out += fnmatch.filter(files, pattern)
            for expattern in excludes:
                files_out = [
                    f
                    for f in files_out
                    if not fnmatch.fnmatch(f, expattern)
                ]
            if not files_out:
                return ""
            return func(files_out).strip()
        checkers.append((helper, name, color, level))
        return helper
    return decorator


def which_vcs():
    """
    Determine the vcs to use by looking for a '.<vcs>' directory.
    """

    while True:
        for vcs in VCS:
            if os.path.exists('.%s' % vcs):
                return vcs
        prev = os.getcwd()
        os.chdir('..')
        if prev == os.getcwd():
            # At the filesystem root, so give up.
            raise Exception("No version control system found.")


def interesting_files(vcs):
    """
    Return a list of added or modified files.
    """

    out = call([vcs, 'status']).splitlines()
    r = re.compile(VCS[vcs])
    return [m[0] for m in filter(None, map(r.findall, out))]


def call(seq, shell=False):
    """
    Use Popen to execute `seq` and return stdout.
    """

    return subprocess.Popen(
        seq,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        shell=shell
    ).communicate()[0]


@checker(['*'], excludes=["check.py", "*.json", "*.log", "*.txt"],
         name="Merge Conflicts")
def merge_conficts(files):
    """
    Check for potential merge conflicts that are generated by Git
    by looking at symbols of the like <<<<
    """

    output = []
    r = re.compile(r'^(>>>>>>>|=======|<<<<<<<)')
    for filename in files:
        content = open(filename).read()
        for idx, line in enumerate(content.splitlines()):
            if r.search(line):
                output.append('%s:%d: merge error' % (filename, idx + 1))
    return '\n'.join(output)


@checker(['*.py', '*.yml'], excludes=["check.py"], name="Tabs v.s. Spaces")
def tabs(files):
    """
    Check for evil tab. We want to use space over tab for indentation.
    In sublime text, fix this by highlighting over everything (Ctrl+A),
    then choose on the bottom right "Convert Indentation to Space"
    """

    output = []
    r = re.compile(r'\t')
    for filename in files:
        content = open(filename).read()
        for idx, line in enumerate(content.splitlines()):
            if r.search(line):
                output.append('%s:%d: tabs instead of spaces' % (filename, idx + 1))
    return '\n'.join(output)


@checker(["*.py"], excludes=["tests/check.py"], name="Imports", level="warning")
def imports(files):
    """
    We want import statements to be on separate lines for clarity

    e.g. import x, y, z from A should be
    import x from A
    import y from A
    import z from A
    """

    output = []
    r1 = re.compile(r"import ")
    r3 = re.compile(r",")
    for filename in files:
        content = open(filename).read()
        for idx, line in enumerate(content.splitlines()):
            if r1.search(line) and r3.search(line):
                output.append("%s: %s Imports should be separate expressions" % (filename, idx + 1))
    return "\n".join(output)


@checker(['*'], name="Extraneous Files")
def extraneous_files(files):
    """
    We don't want extraneous files to be syntax checked.
    These includes files like django admin (manage.py),
    .gitignore (prevent certain files from being version controlled),
    shippable.yml (our CI to run tests on commits/pull requests),
    among many other things
    """

    output = []
    allowed_files = [
        "sftp-config.json",
        ".DS_Store",
        ".coverage",
        ".gitignore",
        ".gitattributes",
        "shippable.yml",
        "requirements.txt",
        "README.md"
    ]
    r = re.compile(r'\.save$|\.save\.\d$|[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$')

    for file in files:
        # first check to make sure there aren't additional (typically log) files in the quorum-site directory
        if len(file.split("/")) == 1 and file not in allowed_files:
            output.append(file)

        # now check to make sure that the file name doesn't contain ".save" or a hash at the end
        elif r.search(file):
            output.append(file)

    return '\n'.join(output)


@checker(['*.py'], name="Python Syntax Errors")
def pyflakes(files):
    return call(['pyflakes'] + files)


@checker(['*.py'], name="Python Style Errors")
def pep8(files):
    return call(['pycodestyle', '--show-source', '--show-pep8', '--repeat',
                 '--ignore=E127,E251', '--max-line-length=160'] + files)


@checker(['*.yml'], name="Ansible Syntax Errors")
def ansible_lint(files):
    # Skipping the following rules
    # 602 Don't compare to empty string: https://github.com/ansible/ansible-lint/issues/457
    # 204 Lines should be no longer than 120 chars -- NO
    return call(['ansible-lint', '-x', '204,602'] + files)


@checker(name="Pip Packages Security Auditing", level="warning")
def pip_audting(files):
    result = call(['safety', 'check'])

    if "No known security vulnerabilities found" in result:
        return ""
    return result


@checker(['*.py'], excludes=["tests/check.py", "ansible/filter_plugins/filters.py"], name="Print Statements")
def print_statements(files):
    output = []
    r = re.compile(r"print ")
    for filename in files:
        content = open(filename).read()
        for idx, line in enumerate(content.splitlines()):
            if r.search(line):
                output.append('%s:%d: remove print statement - use logging instead!' % (filename, idx + 1))
    return '\n'.join(output)


def _main():
    print colored("Running linters on current commit...\n", "blue")
    if len(sys.argv) == 1:
        # If there are no arguments, figure out what to do based on VCS
        vcs = which_vcs()
        files = interesting_files(vcs)
    else:
        files = []

        if "--override-linting" in sys.argv[1:]:
            res = raw_input("Are you sure you want to override the linter? (Y/N): ")
            if res == "Y":
                return 0
            else:
                idx = sys.argv.index('--override-linting')
                sys.argv.pop(idx)
        if "--all" in sys.argv[1:]:
            files = [
                fname
                for fname in call("find . -name '*.yml' -o -name '*.py' -o -name '*.html'", shell=True).split('\n')
                if fname != ''
            ]
        else:
            for p in map(Path, sys.argv[1:]):
                if p.isfile():
                    files.append(p)
                else:
                    for f in p.walkfiles():
                        if not any(fnmatch.fnmatch(f, glob) for glob in IGNORE):
                            files.append(f)

    files = filter(os.path.isfile, set(files))
    exitcode = 0
    for checker_func, name, color, level in checkers:
        ret = checker_func(files)

        if ret:
            if level == "warning":
                print name + ": " + colored("WARNING", "yellow")
                print "=============================="
                print ret
            else:
                print name + ": " + colored("FAILED", "red")
                print "=============================="
                print ret
                exitcode = 1

        else:
            print name + ": " + colored("PASSED", "green")

        print

    return exitcode


if __name__ == '__main__':
    sys.exit(_main())
